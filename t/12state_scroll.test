local vt=init()
vterm.vterm_set_utf8(vt, true)
local state = wantstate(vt, "") s

-- Linefeed
push "\n"x24
  ?cursor = 24,0
push "\n"
  scrollrect 0..25,0..80 => +1,+0
  ?cursor = 24,0

reset(state,screen)

-- Index
push "\x1b[25H"
push "\x1bD"
  scrollrect 0..25,0..80 => +1,+0

reset(state,screen)

-- Reverse Index
push "\x1bM"
  scrollrect 0..25,0..80 => -1,+0

reset(state,screen)

-- Linefeed in DECSTBM
push "\x1b[1;10r"
  ?cursor = 0,0
push "\n"x9
  ?cursor = 9,0
push "\n"
  scrollrect 0..10,0..80 => +1,+0
  ?cursor = 9,0

-- Linefeed outside DECSTBM
push "\x1b[20H"
  ?cursor = 19,0
push "\n"
  ?cursor = 20,0

-- Index in DECSTBM
push "\x1b[9;10r"
push "\x1b[10H"
push "\x1bM"
  ?cursor = 8,0
push "\x1bM"
  scrollrect 8..10,0..80 => -1,+0

-- Reverse Index in DECSTBM
push "\x1b[25H"
  ?cursor = 24,0
push "\n"
  # no scrollrect
  ?cursor = 24,0

-- Linefeed in DECSTBM+DECSLRM
push "\x1b[?69h"
push "\x1b[3;10r\x1b[10;40s"
push "\x1b[10;10H\n"
  scrollrect 2..10,9..40 => +1,+0

-- IND/RI in DECSTBM+DECSLRM
push "\x1bD"
  scrollrect 2..10,9..40 => +1,+0
push "\x1b[3;10H\x1bM"
  scrollrect 2..10,9..40 => -1,+0

-- DECRQSS on DECSTBM
push "\x1bP\$qr\x1b\\"
  output "\x1bP1\$r3;10r\x1b\\"

-- DECRQSS on DECSLRM
push "\x1bP\$qs\x1b\\"
  output "\x1bP1\$r10;40s\x1b\\"

-- Setting invalid DECSLRM with !DECVSSM is still rejected
push "\x1b[?69l\x1b[;0s\x1b[?69h"

reset(state,screen)

-- Scroll Down
push "\x1b[S"
  scrollrect 0..25,0..80 => +1,+0
  ?cursor = 0,0
push "\x1b[2S"
  scrollrect 0..25,0..80 => +2,+0
  ?cursor = 0,0
push "\x1b[100S"
  scrollrect 0..25,0..80 => +25,+0

-- Scroll Up
push "\x1b[T"
  scrollrect 0..25,0..80 => -1,+0
  ?cursor = 0,0
push "\x1b[2T"
  scrollrect 0..25,0..80 => -2,+0
  ?cursor = 0,0
push "\x1b[100T"
  scrollrect 0..25,0..80 => -25,+0

-- SD/SU in DECSTBM
push "\x1b[5;20r"
push "\x1b[S"
  scrollrect 4..20,0..80 => +1,+0
push "\x1b[T"
  scrollrect 4..20,0..80 => -1,+0

reset(state,screen)

-- SD/SU in DECSTBM+DECSLRM
push "\x1b[?69h"
push "\x1b[3;10r\x1b[10;40s"
  ?cursor = 0,0
push "\x1b[3;10H"
  ?cursor = 2,9
push "\x1b[S"
  scrollrect 2..10,9..40 => +1,+0
push "\x1b[?69l"
push "\x1b[S"
  scrollrect 2..10,0..80 => +1,+0

-- Invalid boundaries
reset(state,screen)

push "\x1b[100;105r\x1bD"
push "\x1b[5;2r\x1bD"

reset(state,screen)
local state = wantstate(vt, "") -s+me

-- Scroll Down move+erase emulation
push "\x1b[S"
  moverect 1..25,0..80 -> 0..24,0..80
  erase 24..25,0..80
  ?cursor = 0,0
push "\x1b[2S"
  moverect 2..25,0..80 -> 0..23,0..80
  erase 23..25,0..80
  ?cursor = 0,0

-- Scroll Up move+erase emulation
push "\x1b[T"
  moverect 0..24,0..80 -> 1..25,0..80
  erase 0..1,0..80
  ?cursor = 0,0
push "\x1b[2T"
  moverect 0..23,0..80 -> 2..25,0..80
  erase 0..2,0..80
  ?cursor = 0,0

-- DECSTBM resets cursor position
push "\x1b[5;5H"
  ?cursor = 4,4
push "\x1b[r"
  ?cursor = 0,0
