local vt=init()
vterm.vterm_set_utf8(vt, true)
local state = wantstate(vt, "") seb

-- ICH
reset(state,screen)
  erase 0..25,0..80
  ?cursor = 0,0
push "ACD"
push "\x1b[2D"
  ?cursor = 0,1
push "\x1b[@"
  scrollrect 0..1,1..80 => +0,-1
  ?cursor = 0,1
push "B"
  ?cursor = 0,2
push "\x1b[3@"
  scrollrect 0..1,2..80 => +0,-3

-- ICH with DECSLRM
push "\x1b[?69h"
push "\x1b[;50s"
push "\x1b[20G\x1b[@"
  scrollrect 0..1,19..50 => +0,-1

-- ICH outside DECSLRM
push "\x1b[70G\x1b[@"
  # nothing happens

-- DCH
reset(state,screen)
  erase 0..25,0..80
  ?cursor = 0,0
push "ABBC"
push "\x1b[3D"
  ?cursor = 0,1
push "\x1b[P"
  scrollrect 0..1,1..80 => +0,+1
  ?cursor = 0,1
push "\x1b[3P"
  scrollrect 0..1,1..80 => +0,+3
  ?cursor = 0,1

-- DCH with DECSLRM
push "\x1b[?69h"
push "\x1b[;50s"
push "\x1b[20G\x1b[P"
  scrollrect 0..1,19..50 => +0,+1

-- DCH outside DECSLRM
push "\x1b[70G\x1b[P"
  # nothing happens

-- ECH
reset(state,screen)
  erase 0..25,0..80
  ?cursor = 0,0
push "ABC"
push "\x1b[2D"
  ?cursor = 0,1
push "\x1b[X"
  erase 0..1,1..2
  ?cursor = 0,1
push "\x1b[3X"
  erase 0..1,1..4
  ?cursor = 0,1
# ECH more columns than there are should be bounded
push "\x1b[100X"
  erase 0..1,1..80

-- IL
reset(state,screen)
  erase 0..25,0..80
  ?cursor = 0,0
push "A\r\nC"
  ?cursor = 1,1
push "\x1b[L"
  scrollrect 1..25,0..80 => -1,+0
  # TODO: ECMA-48 says we should move to line home, but neither xterm nor
  # xfce4-terminal do this
  ?cursor = 1,1
push "\rB"
  ?cursor = 1,1
push "\x1b[3L"
  scrollrect 1..25,0..80 => -3,+0

-- IL with DECSTBM
push "\x1b[5;15r"
push "\x1b[5H\x1b[L"
  scrollrect 4..15,0..80 => -1,+0

-- IL outside DECSTBM
push "\x1b[20H\x1b[L"
  # nothing happens

-- IL with DECSTBM+DECSLRM
push "\x1b[?69h"
push "\x1b[10;50s"
push "\x1b[5;10H\x1b[L"
  scrollrect 4..15,9..50 => -1,+0

-- DL
reset(state,screen)
  erase 0..25,0..80
  ?cursor = 0,0
push "A\r\nB\r\nB\r\nC"
  ?cursor = 3,1
push "\x1b[2H"
  ?cursor = 1,0
push "\x1b[M"
  scrollrect 1..25,0..80 => +1,+0
  ?cursor = 1,0
push "\x1b[3M"
  scrollrect 1..25,0..80 => +3,+0
  ?cursor = 1,0

-- DL with DECSTBM
push "\x1b[5;15r"
push "\x1b[5H\x1b[M"
  scrollrect 4..15,0..80 => +1,+0

-- DL outside DECSTBM
push "\x1b[20H\x1b[M"
  # nothing happens

-- DL with DECSTBM+DECSLRM
push "\x1b[?69h"
push "\x1b[10;50s"
push "\x1b[5;10H\x1b[M"
  scrollrect 4..15,9..50 => +1,+0

-- DECIC
reset(state,screen)
  erase 0..25,0..80
push "\x1b[20G\x1b[5'}"
  scrollrect 0..25,19..80 => +0,-5

-- DECIC with DECSTBM+DECSLRM
push "\x1b[?69h"
push "\x1b[4;20r\x1b[20;60s"
push "\x1b[4;20H\x1b[3'}"
  scrollrect 3..20,19..60 => +0,-3

-- DECIC outside DECSLRM
push "\x1b[70G\x1b['}"
  # nothing happens

-- DECDC
reset(state,screen)
  erase 0..25,0..80
push "\x1b[20G\x1b[5'~"
  scrollrect 0..25,19..80 => +0,+5

-- DECDC with DECSTBM+DECSLRM
push "\x1b[?69h"
push "\x1b[4;20r\x1b[20;60s"
push "\x1b[4;20H\x1b[3'~"
  scrollrect 3..20,19..60 => +0,+3

-- DECDC outside DECSLRM
push "\x1b[70G\x1b['~"
  # nothing happens

-- EL 0
reset(state,screen)
  erase 0..25,0..80
  ?cursor = 0,0
push "ABCDE"
push "\x1b[3D"
  ?cursor = 0,2
push "\x1b[0K"
  erase 0..1,2..80
  ?cursor = 0,2

-- EL 1
reset(state,screen)
  erase 0..25,0..80
  ?cursor = 0,0
push "ABCDE"
push "\x1b[3D"
  ?cursor = 0,2
push "\x1b[1K"
  erase 0..1,0..3
  ?cursor = 0,2

-- EL 2
reset(state,screen)
  erase 0..25,0..80
  ?cursor = 0,0
push "ABCDE"
push "\x1b[3D"
  ?cursor = 0,2
push "\x1b[2K"
  erase 0..1,0..80
  ?cursor = 0,2

-- SEL
reset(state,screen)
  erase 0..25,0..80
  ?cursor = 0,0
push "\x1b[11G"
  ?cursor = 0,10
push "\x1b[?0K"
  erase 0..1,10..80 selective
  ?cursor = 0,10
push "\x1b[?1K"
  erase 0..1,0..11 selective
  ?cursor = 0,10
push "\x1b[?2K"
  erase 0..1,0..80 selective
  ?cursor = 0,10

-- ED 0
reset(state,screen)
  erase 0..25,0..80
  ?cursor = 0,0
push "\x1b[2;2H"
  ?cursor = 1,1
push "\x1b[0J"
  erase 1..2,1..80
  erase 2..25,0..80
  ?cursor = 1,1

-- ED 1
reset(state,screen)
  erase 0..25,0..80
  ?cursor = 0,0
push "\x1b[2;2H"
  ?cursor = 1,1
push "\x1b[1J"
  erase 0..1,0..80
  erase 1..2,0..2
  ?cursor = 1,1

-- ED 2
reset(state,screen)
  erase 0..25,0..80
  ?cursor = 0,0
push "\x1b[2;2H"
  ?cursor = 1,1
push "\x1b[2J"
  erase 0..25,0..80
  ?cursor = 1,1

-- ED 3
push "\x1b[3J"
  sb_clear

-- SED
reset(state,screen)
  erase 0..25,0..80
push "\x1b[5;5H"
  ?cursor = 4,4
push "\x1b[?0J"
  erase 4..5,4..80 selective
  erase 5..25,0..80 selective
  ?cursor = 4,4
push "\x1b[?1J"
  erase 0..4,0..80 selective
  erase 4..5,0..5 selective
  ?cursor = 4,4
push "\x1b[?2J"
  erase 0..25,0..80 selective
  ?cursor = 4,4

-- DECRQSS on DECSCA
push "\x1b[2\"q"
push "\x1bP\$q\"q\x1b\\"
  output "\x1bP1\$r2\"q\x1b\\"

local state = wantstate(vt, "") -s+m

-- ICH move+erase emuation
reset(state,screen)
  erase 0..25,0..80
  ?cursor = 0,0
push "ACD"
push "\x1b[2D"
  ?cursor = 0,1
push "\x1b[@"
  moverect 0..1,1..79 -> 0..1,2..80
  erase 0..1,1..2
  ?cursor = 0,1
push "B"
  ?cursor = 0,2
push "\x1b[3@"
  moverect 0..1,2..77 -> 0..1,5..80
  erase 0..1,2..5

-- DCH move+erase emulation
reset(state,screen)
  erase 0..25,0..80
  ?cursor = 0,0
push "ABBC"
push "\x1b[3D"
  ?cursor = 0,1
push "\x1b[P"
  moverect 0..1,2..80 -> 0..1,1..79
  erase 0..1,79..80
  ?cursor = 0,1
push "\x1b[3P"
  moverect 0..1,4..80 -> 0..1,1..77
  erase 0..1,77..80
  ?cursor = 0,1
